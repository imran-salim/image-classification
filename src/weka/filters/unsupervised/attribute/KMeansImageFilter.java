package weka.filters.unsupervised.attribute;


import no.uib.cipr.matrix.*;
import no.uib.cipr.matrix.Matrix;
import no.uib.cipr.matrix.Vector;
import weka.core.*;
import weka.filters.SimpleBatchFilter;
import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.*;

/**
 * A filter that can be used to process a collection of images for classification or clustering. It applies
 * spherical k-means to image batches extracted from the first batch of images it receives and uses
 * the resulting k-means centroids to process images into feature vectors suitable for classification or
 * clustering.
 *
 * The first attribute in the input data is required to be a string attribute with the file names of images.
 */
public class KMeansImageFilter extends SimpleBatchFilter {

	/** The seed for the random number generator. */
	protected int m_seed = 0;

	/** The width and height of each extracted image patch in pixels. */
	protected int m_cropSize = 8;

	/** The number of patches to be extracted from each image. */
	protected int m_numPatchesPerImage = 1;

	/** The number of clusters aka filters aka dictionary atoms to use. */
	protected int m_K = 1000;

	/** The stride for the application of the filters (when feature vectors are computed). */
	protected int m_stride = 4;

	/** The height and width of the pool used to reduce the dimensionality of the feature vectors. */
	protected int m_poolSize = 2;

	/** The dictionary matrix, with one column per filter (aka atom). */
	protected Matrix m_D;

	/**
	 * The method used to establish the format of the data generated by this filter, as an Instances object.
	 *
	 * @param data the input dataset, with a string attribute containing the file names of the images
	 * @return an Instances object that provides the "header" information for the data generated by this filter
	 * (i.e., an Instances object that does not contain any actual instances but does contain a list of attributes).
	 */
	public Instances determineOutputFormat(Instances data) {

		if (m_Debug) {
			System.err.println("Determining output format.");
		}
		int imgSize = -1;
		for (int i = 0; i < data.numInstances(); i++) {
			String fileName = data.instance(i).stringValue(0);
			BufferedImage img = null;
			try {
				img = ImageIO.read(new File(fileName));
			} catch (Exception ex) {
				System.err.println("Could not load: " + fileName);
			}
			if (img.getWidth() != img.getHeight()) {
				throw new IllegalArgumentException("Image " + fileName + " is not square.");
			}
			if (imgSize == -1) {
				imgSize = img.getWidth();
			} else if (imgSize != img.getWidth()) {
				throw new IllegalArgumentException("Image " + fileName + " has different size.");
			}
		}
		if (m_Debug) {
			System.err.println("Image size is: " + imgSize);
		}
		if (((imgSize - m_cropSize) % m_stride) != 0) {
			throw new IllegalArgumentException("Image height not compatible with patch size and stride");
		}
		if ((1 + ((imgSize - m_cropSize) / m_stride)) % m_poolSize != 0) {
			throw new IllegalArgumentException("Pool size not compatible with raw features.");
		}

		int nFeatPerFilterAndDimension = (1 + ((imgSize - m_cropSize) / m_stride)) / m_poolSize;
		int numFeatures = nFeatPerFilterAndDimension * nFeatPerFilterAndDimension * m_K;

		ArrayList<Attribute> atts = new ArrayList<>(numFeatures + 1);
		for (int i = 0; i < numFeatures; i++) {
			atts.add(new Attribute("x" + (i + 1)));
		}
		if (data.classIndex() > -1) {
			atts.add((Attribute) data.classAttribute().copy());
		}
		Instances output = new Instances("features", atts, 0);
		output.setClassIndex(output.numAttributes() - 1);
		if (m_Debug) {
			System.err.println("Finished determining output format with " + output.numAttributes() + " attributes.");
		}
		return output;

	}

	/**
	 * The method that processes the given dataset and outputs the filtered data.
	 *
	 * @param data the input data to be filtered, with a string attribute containing the file names of the images
	 * @return the filtered data, consisting of feature vectors ready for other machine learning algorithms
	 */
	public Instances process(Instances data) throws Exception {

		// We will need a random number generator
		Random rand = new Random(m_seed);

		// Establish number of rows and columns for data matrix X
		int numPatchPixels = m_cropSize * m_cropSize;
		int numPatchValues = numPatchPixels * 3; // Three colour channels
		int numPatches = m_numPatchesPerImage * data.numInstances();

		// Create constant vectors that we will reuse many times to center the values in each patch
		Vector oneOverNumPatchValues = constantVector(1.0 / numPatchValues, numPatchValues);
		Vector allOnesNumPatchValues = constantVector(1.0, numPatchValues);

		// Is this the first batch of data passed through the filter (i.e., the filter bank has not been
		// created yet)?
		if (!isFirstBatchDone()) {

			// Read image patches, normalize patches, and turn them into columns in the matrix X
			Matrix X = new DenseMatrix(numPatchValues, numPatches);
			int colIndex = 0;
			for (int i = 0; i < data.numInstances(); i++) {
				String fileName = data.instance(i).stringValue(0);
				BufferedImage img = null;
				try {
					img = ImageIO.read(new File(fileName));
					int xmax = 1 + img.getWidth() - m_cropSize;
					int ymax = 1 + img.getHeight() - m_cropSize;
					for (int p = 0; p < m_numPatchesPerImage; p++) {
						BufferedImage patch = img.getSubimage(rand.nextInt(xmax), rand.nextInt(ymax), m_cropSize, m_cropSize);
						int index = 0;
						Vector vec = new DenseVector(numPatchValues);
						for (int j = 0; j < m_cropSize; j++) {
							for (int k = 0; k < m_cropSize; k++) {
								int rgb = patch.getRGB(k, j);
								int r = (rgb >> 16) & 0xFF;
								int g = (rgb >> 8) & 0xFF;
								int b = (rgb & 0xFF);
								vec.set(index, r);
								vec.set(numPatchPixels + index, g);
								vec.set(2 * numPatchPixels + index, b);
								index++;
							}
						}
						Vector centeredVec = vec.add(-vec.dot(oneOverNumPatchValues), allOnesNumPatchValues);
						double norm = centeredVec.norm(Vector.Norm.Two);
						Vector normalizedVec = centeredVec.scale(1.0 / Math.sqrt((norm * norm) / vec.size() + 10));
						for (int r = 0; r < normalizedVec.size(); r++) {
							X.set(r, colIndex, normalizedVec.get(r));
						}
						colIndex++;
					}
				} catch (IOException e) {
					System.err.println("File " + fileName + " could not be read");
				}
			}
			if (m_Debug) {
				System.err.println("Calculating mean value for each pixel in X.");
			}
			Vector mean = X.mult(constantVector(1.0 / numPatches, numPatches), new DenseVector(numPatchValues));

			if (m_Debug) {
				System.err.println("Calculating centered version of X and storing it in S.");
			}
			Matrix S = new DenseMatrix(X);
			S = (new DenseMatrix(mean)).transBmultAdd(-1.0, new DenseMatrix(constantVector(1.0, numPatches)), S);

			if (m_Debug) {
				System.err.println("Calculating covariance matrix.");
			}
			Matrix cov = (new UpperSPDDenseMatrix(numPatchValues)).rank1(1.0 / numPatches, S);

			if (m_Debug) {
				System.err.println("Performing eigenvalue decomposition.");
			}
			SymmDenseEVD evd = SymmDenseEVD.factorize(cov);
			double[] evals = evd.getEigenvalues();
			Matrix V = evd.getEigenvectors();
			Matrix E = new UpperSymmDenseMatrix(evals.length);
			for (int i = 0; i < evals.length; i++) {
				E.set(i, i, 1.0 / Math.sqrt(evals[i] + 0.1));

			}
			if (m_Debug) {
				System.err.println("Whitening data.");
			}
			X = V.mult(E, new DenseMatrix(V.numRows(), E.numColumns())).transBmult(V, new UpperSymmDenseMatrix(V.numRows())).
					mult(X, new DenseMatrix(V.numRows(), X.numColumns()));

			// =================
			// SPHERICAL K-MEANS
			// =================

			System.err.println("Initializing dictionary.");
			// Initialize dictionary with random normalized values
			m_D = new DenseMatrix(X.numRows(), m_K);
			for (int i = 0; i < m_K; i++) {
				for (int j = 0; j < X.numRows(); j++) {
					double randomVal = rand.nextGaussian();
					m_D.set(j, i, randomVal);
				}
			}
			// Scale the values to unit length
			for (int i = 0; i < m_K; i++) {
				double length = Matrices.getColumn(m_D, i).norm(Vector.Norm.Two);
				for (int j = 0; j < X.numRows(); j++) {
					m_D.set(j, i, m_D.get(j, i) / length);
				}
			}

			double oldSSE = 1.0e8;
			double newSSE = 1.0e7 ;
			double stepSize = 1.0e-6;
			double testVal = 1.0e-3;
			int iter = 0;
			// Init S matrix
			S = new DenseMatrix(m_K, numPatches);
			System.err.println("Running spherical k-means.");
			// Update S matrix each iteration step
			while ((oldSSE - newSSE) * stepSize > testVal) {
				oldSSE = newSSE;
				// Update dictionary of centroids
				m_D.transAmult(X, S);
				double absVal = 0;
				double maxVals[] = new double[S.numColumns()];
				int coordinates[] = new int[S.numColumns()];
				System.err.println("Calculating Initial S matrix.");
				for (int col = 0; col < S.numColumns(); col++) {
					for (int row = 0; row < S.numRows(); row++) {
						absVal = Math.abs(S.get(row, col));
						if (absVal > maxVals[col]) {
							maxVals[col] = S.get(row, col);
							coordinates[col] = row;
						}
					}
				}
				System.err.println("Setting appropriate elements to zero.");
				S.zero();
				System.err.println("Updating dictionary.");
				for (int col = 0; col < S.numColumns(); col++) {
					S.set(coordinates[col], col, maxVals[col]);
				}
				X.transBmultAdd(S, m_D);
				System.err.println("Normalizing dictionary.");
				// Scale the values to unit length
				for (int iPrime = 0; iPrime < m_K; iPrime++) {
					double length = Matrices.getColumn(m_D, iPrime).norm(Vector.Norm.Two);
					for (int jPrime = 0; jPrime < X.numRows(); jPrime++) {
						m_D.set(jPrime, iPrime, m_D.get(jPrime, iPrime) / length);
					}
				}

				System.err.println("Calculating squared error.");
				newSSE = calculateSumOfSquaredErrors(X, S);
				System.err.println("SSE at iteration " + iter + ": " + newSSE);
				iter++;
			}
		}

		// ======================
		// CREATE FEATURE VECTORS
		// ======================

		Instances newInstances = new Instances(determineOutputFormat(data));
		Vector vec = new DenseVector(numPatchValues);
		Vector feature = new DenseVector(m_K);
		String fileName = data.instance(0).stringValue(0);
		BufferedImage img = ImageIO.read(new File(fileName));
		int numOfStrides = ((img.getWidth() - m_cropSize) / m_stride) + 1;
		int numOfPatches = numOfStrides * numOfStrides;
		int poolArea = m_poolSize * m_poolSize;
		double[][][] featureMaps = new double[m_K + 1][numOfStrides][numOfStrides];

		for (int inst = 0; inst < data.numInstances(); inst++) {
			fileName = data.instance(inst).stringValue(0);
			img = ImageIO.read(new File(fileName));
			double[] pooledFeatureMaps = new double[m_K * (numOfPatches / poolArea) + 1];
			int featureVecX = 0;
			int featureVecY = 0;
			for (int y = 0; y < img.getHeight() - m_cropSize; ) {
				for (int x = 0; x < img.getWidth() - m_cropSize; ) {
					BufferedImage patch = img.getSubimage(x, y, m_cropSize, m_cropSize);
					int index = 0;
					for (int j = 0; j < m_cropSize; j++) {
						for (int k = 0; k < m_cropSize; k++) {
							int rgb = patch.getRGB(k, j);
							int r = (rgb >> 16) & 0xFF;
							int g = (rgb >> 8) & 0xFF;
							int b = (rgb & 0xFF);
							vec.set(index, r);
							vec.set(numPatchPixels + index, g);
							vec.set(2 * numPatchPixels + index, b);
							index++;
						}
					}
					x += m_stride;
					Vector centeredVec = vec.add(-vec.dot(oneOverNumPatchValues), allOnesNumPatchValues);
					double norm = centeredVec.norm(Vector.Norm.Two);
					Vector normalizedVec = centeredVec.scale(1.0 / Math.sqrt((norm * norm) / vec.size() + 10));
					m_D.transMult(normalizedVec, feature);
					for (int vecIdx = 0; vecIdx < feature.size(); vecIdx++) {
						featureMaps[vecIdx][featureVecY][featureVecX] = Math.max(0.0, feature.get(vecIdx));
					}
					featureVecX++;
				}
				featureVecX = 0;
				y += m_stride;
				featureVecY++;
			}
			// Pool feature maps
			int globalCentroidIdx = 0;
			for (int centroidIdx = 0; centroidIdx < m_K; centroidIdx++) {
				for (int patchY = 0; patchY <= numOfStrides - m_poolSize; ) {
					for (int patchX = 0; patchX <= numOfStrides - m_poolSize; ) {
						double avg = 0.0;
						for (int poolY = 0; poolY < m_poolSize; poolY++) {
							for (int poolX = 0; poolX < m_poolSize; poolX++) {
								avg += featureMaps[centroidIdx][poolY + patchY][poolX + patchX];
							}
						}
						pooledFeatureMaps[globalCentroidIdx++] = avg / poolArea;
						patchX += m_poolSize;
					}
					patchY += m_poolSize;
				}
			}
			pooledFeatureMaps[pooledFeatureMaps.length - 1] = data.instance(inst).classValue();
			newInstances.add(new DenseInstance(1.0, pooledFeatureMaps));
		}
		return newInstances;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// helper methods
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * A utility method for calculating the sum of squared errors during k-means iterations
	 * based on the X matrix, the current S matrix, and the current dictionary stored in
	 * a member variable. Useful for checking whether the error decreases monotonically,
	 * which it should if k-means has been implemented correctly.
	 *
	 * @param X the X matrix
	 * @param S the S matrix
	 * @return the sum of squared errors
	 */
	protected double calculateSumOfSquaredErrors(Matrix X, Matrix S) {

		double SSE = 0;
		for (int i = 0; i < X.numColumns(); i++) {
			Vector projected = m_D.mult(Matrices.getColumn(S, i), new DenseVector(X.numRows()));
			double n = Matrices.getColumn(X, i).add(-1.0, projected).norm(Vector.Norm.Two);
			SSE += n * n;
		}
		return SSE;
	}

	/**
	 * The info shown in the GUI.
	 * @return the info describing the filter.
	 */
	public String globalInfo() {
		return "This filter performs feature extraction from images using the spherical k-means algorithm.";
	}

	/**
	 * The capabilities of this filter.
	 * @return the capabilities
	 */
	public Capabilities getCapabilities() {
		Capabilities result = super.getCapabilities();
		result.enable(Capabilities.Capability.STRING_ATTRIBUTES);
		result.enableAllClasses();
		result.enable(Capabilities.Capability.NO_CLASS); // Filter doesn't require class to be set
		result.enable(Capabilities.Capability.MISSING_CLASS_VALUES);
		return result;
	}

	/**
	 * We need to have access to the full input format so that we can read the images.
	 *
	 * @return true
	 */
	public boolean allowAccessToFullInputFormat() {
		return true;
	}

	/**
	 * Plots a vector as an image, assuming the image is square and has 3 colour channels given consecutively.
	 * This method can potentially be used for debugging purposes.
	 *
	 * @param v the vector to plot
	 * @param rescale whether to rescale the data to the 0-255 range before plotting it
	 */
	protected void plotVector(Vector v, boolean rescale) {
		class MyPanel extends JPanel {
			protected void paintComponent(Graphics gr) {
				super.paintComponent(gr);
				int dim = (int) Math.round(Math.sqrt(v.size() / 3));
				int xSize = getWidth() / dim;
				int ySize = getHeight() / dim;
				int x = 0;
				int y = -ySize;
				double[] min = new double[3];
				double[] max = new double[3];
				if (rescale) { // Find minimum and maximum "intensity" value for each channel
					for (int i = 0; i < v.size() / 3; i++) {
						if (i % dim == 0) {
							x = 0;
							y += ySize;
						}
						double r = v.get(i); double g = v.get(i + v.size() / 3); double b = v.get(i + 2 * v.size() / 3);
						if (min[0] > r) { min[0] = r; } if (min[1] > g) { min[1] = g; } if (min[2] > b) { min[2] = b; }
						if (max[0] < r) { max[0] = r; } if (max[1] < g) { max[1] = g; } if (max[2] < b) { max[2] = b; }
						x += xSize;
					}
					x = 0;
					y = -ySize;
				} else {
					for (int i = 0; i < 3; i++) {
						max[i] = 255.0;
					}
				}
				for (int i = 0; i < v.size() / 3; i++) {
					if (i % dim == 0) {
						x = 0;
						y += ySize;
					}
					int r = (int) (255.0 * ((v.get(i) - min[0]) / (max[0] - min[0])));
					int g = (int) (255.0 * ((v.get(i + v.size() / 3) - min[1]) / (max[1] - min[1])));
					int b = (int) (255.0 * ((v.get(i + 2 * v.size() / 3) - min[2]) / (max[2] - min[2])));
					gr.setColor(new Color(r, g, b));
					gr.fillRect(x, y, xSize, ySize);
					x += xSize;
				}
			}
		}
		MyPanel mainPanel = new MyPanel();
		JDialog d = new JDialog();
		d.setModal(true);
		d.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		d.add(mainPanel);
		d.setSize(10 * (int) Math.round(Math.sqrt(v.size())), 2 + 10 * (int) Math.round(Math.sqrt(v.size())));
		d.setResizable(false);
		d.setVisible(true);
	}

	/**
	 * Returns a constant DenseVector with the given value in each slot.
	 *
	 * @param value  the constant to use
	 * @param length the length of the vector
	 * @return DenseVector
	 */
	protected DenseVector constantVector(double value, int length) {
		double[] v = new double[length];
		Arrays.fill(v, value);
		return new DenseVector(v);
	}

	@OptionMetadata(
			displayName = "Seed for random number generation",
			description = "The seed value used by the random number generator.",
			displayOrder = 1,
			commandLineParamName = "S",
			commandLineParamSynopsis = "-S")
	public int getSeed() {
		return m_seed;
	}
	public void setSeed(int seed) {
		this.m_seed = seed;
	}

	@OptionMetadata(
			displayName = "Patch size to use (value X means X x X patches will be used)",
			description = "The patch size to use (value X means X x X patches will be used).",
			displayOrder = 2,
			commandLineParamName = "size",
			commandLineParamSynopsis = "-size")
	public int getCropSize() {
		return m_cropSize;
	}
	public void setCropSize(int cropSize) {
		this.m_cropSize = cropSize;
	}

	@OptionMetadata(
			displayName = "Number of patches per image",
			description = "The number of patches to be extracted per image.",
			displayOrder = 3,
			commandLineParamName = "numPatches",
			commandLineParamSynopsis = "-numPatches")
	public int getNumPatchesPerImage() {
		return m_numPatchesPerImage;
	}
	public void setNumPatchesPerImage(int numPatchesPerImage) {
		this.m_numPatchesPerImage = numPatchesPerImage;
	}

	@OptionMetadata(
			displayName = "Number of clusters",
			description = "The number of clusters/filters/dictionary atoms to learn.",
			displayOrder = 4,
			commandLineParamName = "K",
			commandLineParamSynopsis = "-K")
	public int getK() {
		return m_K;
	}
	public void setK(int K) {
		this.m_K = K;
	}

	@OptionMetadata(
			displayName = "Stride",
			description = "The stride to use when filters are applied to an image (both directions).",
			displayOrder = 5,
			commandLineParamName = "stride",
			commandLineParamSynopsis = "-stride")
	public int getStride() {
		return m_stride;
	}
	public void setStride(int stride) {
		this.m_stride = stride;
	}

	@OptionMetadata(
			displayName = "Pool size",
			description = "The size of the pool to use when creating features (both directions).",
			displayOrder = 6,
			commandLineParamName = "pool",
			commandLineParamSynopsis = "-pool")
	public int getPoolSize() {
		return m_poolSize;
	}
	public void setPoolSize(int pool) {
		this.m_poolSize = pool;
	}

	/**
	 * The main method used for running this filter from the command-line interface.
	 *
	 * @param options the command-line options
	 */
	public static void main(String[] options) { runFilter(new KMeansImageFilter(), options); }
}
